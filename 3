#include <stdlib.h>
#include <stdio.h>
#include "interpreter.h"
#include "y.tab.h"

// Hold ex() return value.
// NULL if no return value (eg declaration, assignment).
typedef conNodeType ret;

nodeType * _ONE = NULL;
nodeType * ONE() {
    if (_ONE != NULL) return _ONE;
    _ONE = (nodeType*)xmalloc(sizeof(nodeType));

    _ONE->type = nodeCon;
    _ONE->con = *(conNodeType *)xmalloc(sizeof(conNodeType));
    _ONE->con.i = 1;
    _ONE->con.r = 1.0;
    _ONE->con.b = 1;

    return _ONE;
}


/* Execute a subtree.
 * Return node evaluation.
 */
ret * ex(nodeType *p) {
    ret * retv = NULL;

    // Early exit on EOTree.
    if (!p) return 0;

    switch(p->type) {
        case nodeCon:
            // assert conNodeType
            retv = xmalloc(sizeof(ret));
            retv->type = p->con.type;
            switch(p->con.type){
                case INTTYPE:
                    retv->i = p->con.i;
                    break;
                case REALTYPE:
                    retv->r = p->con.r;
                    break;
                case BOOLTYPE:
                    retv->b = p->con.b;
                    break;
                default:
                    yyerror("Unrecognized type.");
            }

            return retv;

        case nodeId:
            {
                symrec * s = getsym(p->id.name);
                if(s == NULL){
                    fprintf(stderr, "There is not such '%s' variable in the symtable\n", p->id.name);
                    exit(1);
                }

                retv = xmalloc(sizeof(ret));
                retv->type = s->type;
                switch(s->type){
                    case INTTYPE:
                        retv->i = s->i;
                        break;
                    case REALTYPE:
                        retv->r = s->r;
                        break;
                    case BOOLTYPE:
                        retv->b = s->b;
                        break;
                    default:
                        yyerror("Unrecognized type.");
                }

                return retv;
            }

        case nodeOpr:
            switch(p->opr.oper) {
                case WHILE:
                    while(ex(p->opr.op[0]))
                        ex(p->opr.op[1]);
                    return NULL;

                case FOR:
                    {
                        /* 0: var
                         * 1: initial value
                         * 2: upper boundary
                         * 3: body
                         */
                        // var = exp;
                        // TODO: test me
                        // symrec * s = getsym(p->opr.op[0]->id.name);
                        //ex(opr(EQ, 2, id(s), p->opr.op[1]));
                        ex(opr(EQ, 2, p->opr.op[0], p->opr.op[1]));

                        // iterator < boundary
                        while(ex(opr(LTE, 2, p->opr.op[0], p->opr.op[2]))){
                            // exec
                            ex(p->opr.op[3]);
                            // inc
                            ex(opr(PLUS, 2, p->opr.op[0], ONE()));
                        }
                        return 0;
                    }

                case IF:
                    if (ex(p->opr.op[0]))
                        ex(p->opr.op[1]); // IF
                    else if (p->opr.nops > 2)
                        ex(p->opr.op[2]); // ELSE
                    return 0;


                case PRINT:     printf("%d\n", ex(p->opr.op[0], symTable)); return 0;
                case ';':       ex(p->opr.op[0], symTable); return ex(p->opr.op[1], symTable);
                case '=':       {
                                    symrec * s= getsymTable(p->opr.op[0]->id.name, symTable);
                                    if(s == NULL){
                                        printf("there is not such '%s' varibale in the symtable\n", p->opr.op[0]->id.name);
                                        exit(0);
                                    }
                                    return s->value = ex(p->opr.op[1], symTable);
                                }
                case UMINUS:    return -ex(p->opr.op[0], symTable);
                case '+':       return ex(p->opr.op[0], symTable) + ex(p->opr.op[1], symTable);
                case '-':       return ex(p->opr.op[0], symTable) - ex(p->opr.op[1], symTable);
                case '*':       return ex(p->opr.op[0], symTable) * ex(p->opr.op[1], symTable);
                case '/':       return ex(p->opr.op[0], symTable) / ex(p->opr.op[1], symTable);
                case '<':       return ex(p->opr.op[0], symTable) < ex(p->opr.op[1], symTable);
                case '>':       return ex(p->opr.op[0], symTable) > ex(p->opr.op[1], symTable);
                case GE:        return ex(p->opr.op[0], symTable) >= ex(p->opr.op[1], symTable);
                case LE:        return ex(p->opr.op[0], symTable) <= ex(p->opr.op[1], symTable);
                case NE:        return ex(p->opr.op[0], symTable) != ex(p->opr.op[1], symTable);
                case EQ:        return ex(p->opr.op[0], symTable) == ex(p->opr.op[1], symTable);


            }
   }
    printf("%s\n", "Unable to evaluate node");
    return 0;
}
